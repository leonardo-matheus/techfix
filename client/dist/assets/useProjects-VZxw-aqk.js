import{U as n,r,V as g}from"./index-BZshN7x3.js";async function p(){return(await fetch("/techfix/data/projects.json")).json()}const j={async getPublicProjects(){try{const{data:t}=await n.get("/projects/public");return t}catch{return p()}},async getProjectBySlug(t){try{const{data:e}=await n.get(`/projects/public/${t}`);return e}catch{const c=(await p()).find(a=>a.slug===t);if(!c)throw new Error("Project not found");return c}},async getCategories(){try{const{data:t}=await n.get("/projects/categories");return t}catch{const t=await p();return[...new Set(t.map(c=>c.category))]}},async getProjects(t){const{data:e}=await n.get("/projects",{params:t});return e},async getProject(t){const{data:e}=await n.get(`/projects/${t}`);return e},async createProject(t){const{data:e}=await n.post("/projects",t);return e},async updateProject(t,e){const{data:c}=await n.put(`/projects/${t}`,e);return c},async deleteProject(t){await n.delete(`/projects/${t}`)},async reorderProjects(t){await n.post("/projects/reorder",{projects:t})}};function b(){const[t,e]=r.useState([]),[c,a]=r.useState(!0),[d,i]=r.useState(null);return r.useEffect(()=>{async function u(){try{const P=await j.getPublicProjects();e(P)}catch(P){i(g(P))}finally{a(!1)}}u()},[]),{projects:t,isLoading:c,error:d}}function L(t){const[e,c]=r.useState(null),[a,d]=r.useState(!0),[i,u]=r.useState(null);return r.useEffect(()=>{async function P(){try{const l=await j.getProjectBySlug(t);c(l)}catch(l){u(g(l))}finally{d(!1)}}t&&P()},[t]),{project:e,isLoading:a,error:i}}function C(){const[t,e]=r.useState([]),[c,a]=r.useState(!0);return r.useEffect(()=>{async function d(){try{const i=await j.getCategories();e(i)}catch{}finally{a(!1)}}d()},[]),{categories:t,isLoading:c}}function m(){const[t,e]=r.useState([]),[c,a]=r.useState(!0),[d,i]=r.useState(null),u=r.useCallback(async s=>{a(!0);try{const o=await j.getProjects(s);e(o),i(null)}catch(o){i(g(o))}finally{a(!1)}},[]);return r.useEffect(()=>{u()},[u]),{projects:t,isLoading:c,error:d,fetchProjects:u,createProject:async s=>{const o=await j.createProject(s);return e(f=>[...f,o]),o},updateProject:async(s,o)=>{const f=await j.updateProject(s,o);return e(w=>w.map(y=>y.id===s?f:y)),f},deleteProject:async s=>{await j.deleteProject(s),e(o=>o.filter(f=>f.id!==s))},reorderProjects:async s=>{await j.reorderProjects(s),u()}}}export{C as a,L as b,m as c,b as u};
